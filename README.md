# Bazel Rules for Maven Respositories

A bazel ruleset creating a more idiomatic bazel representation of a maven repo using a
pinned list of artifacts.

## Overview

*Bazel Rules for maven repositories* allow the specification of a list of artifacts which
constitute maven repository's universe of deps, and exposes these deps into a bazel *repository*
namespace.  The name of the repository specification rule becomes the repository name in Bazel.
For instance the following specification:
 
```python
load("@bazel_tools//tools/build_defs/repo:git.bzl", "git_repository") 
git_repository(name = "maven_repository_rules", path = "../..")
load("@maven_repository_rules//maven:maven.bzl", "maven_repository_specification")
maven_repository_specification(
    name = "maven",
    insecure_artifacts = [
        "com.google.dagger:dagger:1.4",
    ],
    artifacts = {
        "com.google.guava:guava:25.0-jre": "3fd4341776428c7e0e5c18a7c10de129475b69ab9d30aeafbb5c277bb6074fa9",
    }
)
```
 
... results in deps of the format `@maven//com/google/guava:guava` (which can be abbreviated to 
`@maven//com/google/guava`)

Dependency versions are resolved in the single artifact list.  Only one version is permitted within
a repository.

## Coordinate Translation

Translation from maven group/artifact coordinates to bazel package/target coordinates is naive but
orderly.  The logic mirrors the layout of a maven repository, with group_id elements (separated by
`.`) turning into a package hierarchy, and the artifact_id turning into a bazel target. 

### Mangling

Bazel tends not to like package and target names using anything other than `[A-Za-z9-0_]` (though it
can support dashes in some cases).  These rules do a straight mangling of other characters into `_`
in artifact_ids (though not in group_ids because: reasons).

While this typically turns into what you'd expect, there are a few times where it doesn't. 

For instance:

```python
maven_repository_specification(
    name = "maven",
    insecure_artifacts = [
        "org.mockito:mockito-core:1.9.5",
        "joda-time:joda-time:1.1",
    ],
)
```
 
would be referenced in a rule like so:

```python
java_library(
    name = "foo",
    srcs = glob(["*.java"]),
    deps = [
        "@maven//org/mockito:mockito_core",
        "@maven//joda-time:joda_time",
    ],
)
```

> Note: The package/workspace layout generated by the `maven_repository_specification` rule can be
> found at `<workspace>/bazel-<workspace_name>/external/<maven_repo_name>` (all bazel generated
> workspaces are available in `bazel-yourworkspace/external`).  The package structure can be
> inspected if it is confusing.

## Sha verification

Artifacts with SHA headers can be added to `artifacts`, in the form:
`{ "group_id:artifact_id:version": "sha" }`. Artifacts without SHA headers should be added
to `insecure_artifacts` in the form `[ "group_id:artifact_id:version" ]`

The rules will reject artifacts without SHAs that do not go through the `insecure_artifacts`. This
only serves a documentary purpose and it is the responsibility of the project maintainer to do any
off-line validation that the SHA hashes are the properly published hashes.

## Variation

### Packaging
Optionally, an artifact may specify a packaging. Valid artifact coordinates are listable this way:
`"group_id:artifact_id:version[:packaging]"`

At present, only `jar` (default) and `aar` packaging are supported.

### Classifiers

Classifiers have only limited support. An artifact can specify a classifier, but only that or
the unclassified artifact can be used, but not both.

Classifiers are tacked on the end, e.g. `"foo.bar:blah:1.0:jar:some-classifier"`
 
## Limitations

This doesn't assign inter-dependencies between maven artifacts, nor does it hook up annotation
procesors or do other things you might want.  Future versions may support some of these features,
as well as validation that your artifact list is complete to satisfy all its dependencies.  For now,
the generated bazel targets will not include any transitive dependency closure.

Tools like Dagger or AutoValue will need special setup of a `java_plugin` target.  Also, dependencies
like mockito with runtime dependencies on other packages may warrant their own wrapper targets.
